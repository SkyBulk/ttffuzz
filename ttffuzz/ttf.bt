BigEndian();

local int maxGlyfRead = 0; // set to zero to read all the glyph, but very slow :)

//the following locals are masks for "flags" 010 v2 doesn't support #define
local USHORT ARG_1_AND_2_ARE_WORDS = 1<<0;	// If this is set, the arguments are words; otherwise, they are bytes. 
local USHORT ARGS_ARE_XY_VALUES = 1<<1;	// If this is set, the arguments are xy values; otherwise, they are points. 
local USHORT ROUND_XY_TO_GRID = 1<<2;	// For the xy values if the preceding is true. 
local USHORT WE_HAVE_A_SCALE = 1<<3;	// This indicates that there is a simple scale for the component. Otherwise, scale = 1.0. 
local USHORT RESERVED = 1<<4;	// This bit is reserved. Set it to 0. 
local USHORT MORE_COMPONENTS = 1<<5;	// Indicates at least one more glyph after this one. 
local USHORT WE_HAVE_AN_X_AND_Y_SCALE = 1<<6;	// The x direction will use a different scale from the y direction. 
local USHORT WE_HAVE_A_TWO_BY_TWO = 1<<7;	// There is a 2 by 2 transformation that will be used to scale the component. 
local USHORT WE_HAVE_INSTRUCTIONS = 1<<8;	// Following the last component are instructions for the composite character. 
local USHORT USE_MY_METRICS = 1<<9;	// If set, this forces the aw and lsb (and rsb) for the composite to be equal to those from this original glyph. This works for hinted and unhinted characters. 
local USHORT OVERLAP_COMPOUND = 1<<10;	// Used by Apple in GX fonts. 
local USHORT SCALED_COMPONENT_OFFSET = 1<<11;	// Composite designed to have the component offset scaled (designed for Apple rasterizer). 
local USHORT UNSCALED_COMPONENT_OFFSET = 1<<12;	// Composite designed not to have the component offset scaled (designed for the Microsoft TrueType rasterizer). 

// these flags tell us:
// bit	name	description
local UBYTE ON_CURVE 	= 1<<0;	// If set, the point is on the curve; otherwise, it is off the curve. 
local UBYTE X_BYTE 	= 1<<1;	// aka "X-Short" If set, the corresponding x-coordinate is 1 byte long. If not set, 2 bytes. 
local UBYTE Y_BYTE 	= 1<<2; 	// aka "Y-Short" If set, the corresponding y-coordinate is 1 byte long. If not set, 2 bytes. 
//I believe the name x-Short was intended to mean "small" rather than the type SHORT. 
//I've changed the names to X_BYTE and Y_BYTE since they are BYTES if set to 1
local UBYTE REPEAT 	= 1<<3;  // If set, the next byte specifies the number of additional times this set of flags is to be repeated. 
// 		In this way, the number of flags listed can be smaller than the number of points in a character. 
local UBYTE X_TYPE 	= 1<<4;	// This flag has two meanings, depending on how the x-Short flag is set. 
// 		If x-Short is set, this bit describes the sign of the value, 
//			with 1 equalling positive and 0 negative. 
// 		If the x-Short bit is not set and this bit is set, then 
//			the current x-coordinate is the same as the previous x-coordinate. 
// 		If the x-Short bit is not set and this bit is also not set, 
//			the current x-coordinate is a signed 16-bit delta vector. 
local UBYTE Y_TYPE	= 1<<5;	// This flag has two meanings, depending on how the y-Short Vector flag is set. 
//		If y-Short Vector is set, this bit describes the sign of the value, 
//			with 1 equalling positive and 0 negative. 
//		If the y-Short Vector bit is not set and this bit is set, then 
//			the current y-coordinate is the same as the previous y-coordinate. 
//		If the y-Short Vector bit is not set and this bit is also not set, 
//			the current y-coordinate is a signed 16-bit delta vector. 
local UBYTE RES_1	= 1<<6;	// 6 	Res	This bit is reserved. Set it to zero. 
local UBYTE RES_2	= 1<<7;	// 7 	Res	This bit is reserved. Set it to zero. 



typedef unsigned long     TT_Fixed;   /* Signed Fixed 16.16 Float */

typedef signed short    TT_FWord;   /* Distance in FUnits */
typedef unsigned short  TT_UFWord;  /* Unsigned distance */

typedef signed short    TT_Short;

typedef unsigned short  TT_UShort;
typedef signed long     TT_Long;
typedef unsigned long   TT_ULong;
typedef unsigned long   TT_Offset;
typedef OLETIME	LONGDATETIME;

typedef signed short    F2Dot14;

local quad numTables_offset;
local USHORT numTables_n ;
typedef struct tOffsetTable {
	//TT_Fixed SFNT_Ver = {0x00010000};	//sfnt version 0x00010000 for version 1.0. 
	unsigned long SFNT_Ver = {0x00010000};
	numTables_offset = FTell();
	USHORT  numTables = {5, 10 ,16};	//Number of tables.  
	//USHORT  numTables = {5};	//Number of tables.  
	numTables_n = numTables;
	USHORT  searchRange;	//(Maximum power of 2 <= numTables) x 16. 
	USHORT  entrySelector;	// Log2(maximum power of 2 <= numTables). 
	USHORT  rangeShift;	// NumTables x 16-searchRange. 
};



typedef struct tcmap_format0 {
	cmap_subtable = FTell();
	USHORT format;// = {0x0};	// Format number is set to 0.  
	USHORT length = {262};	// This is the length in bytes of the subtable. 
	USHORT language;	// Please see "Note on the language field in 'cmap' subtables" in this document. 
	BYTE glyphIdArray[256];	// An array that maps character codes to glyph index values. 

};

typedef struct SubHeader {
	uint16	firstCode;//	First valid low byte for this SubHeader.
	//uint16	entryCount;//	Number of valid low bytes for this SubHeader.
	UBYTE  entryCount_h = {0};
	UBYTE  entryCount_l;
	int16	idDelta;
	uint16	idRangeOffset;
	local quad curPos = FTell();
	//FSeek(curPos + idRangeOffset - 2);
	//Printf("entryCount_l is %d\n", entryCount_l);
	USHORT glyphIdArray[entryCount_l];
	//FSeek(curPos);
};

typedef struct tcmap_format2 {
	cmap_subtable = FTell();
	USHORT format ;	// Format number is set to 0.  
	USHORT length;	// This is the length in bytes of the subtable. 
	USHORT language;
	//USHORT	subHeaderKeys[256];//	Array that maps high bytes to subHeaders: value is subHeader index .
	local int maxidx = 0, i = 0;
	for (i = 0; i < 256; ++i)
	{
		USHORT subHeaderKeys = {0, 1000};
		if (subHeaderKeys > maxidx)
			maxidx = subHeaderKeys;
	}
	maxidx = maxidx / 8;
	for (i = maxidx; i >= 0; i --)
	{
		uint16	firstCode;//	First valid low byte for this SubHeader.
		uint16	entryCount = {100};//	Number of valid low bytes for this SubHeader.
		int16	idDelta;
		local uint16 tmp_idrange = i * 8 + 4;
		uint16	idRangeOffset = {tmp_idrange};
		
	}
	USHORT unknow_d;
	USHORT glyphIdArray[100];

	local quad tcmap_format2_end = FTell();
	local USHORT format2_length = tcmap_format2_end - cmap_subtable;
	FSeek(cmap_subtable + 2);
	//Printf("tcmap_format2_end %d\n", tcmap_format2_end);
	//Printf("cmap_subtable %d\n", cmap_subtable);
	//Printf("format2_length %d\n", format2_length);
	USHORT length = {format2_length};
	FSeek(tcmap_format2_end);
};
local USHORT randomlength;
typedef struct tcmap_format4 {
	cmap_subtable = FTell();
	USHORT format ;	// Format number is set to 4.  
	USHORT length;	// This is the length in bytes of the subtable.  
	randomlength = length;
	USHORT language;	// Please see "Note on the language field in 'cmap' subtables" in this document. 
	USHORT segCountX2;	//  2 x segCount. 
	//Printf("segCountX2 is %d\n", segCountX2);
	USHORT searchRange;	//  2 x (2**floor(log2(segCount))) 
	USHORT entrySelector;	//  log2(searchRange/2) 
	USHORT rangeShift;	//  2 x segCount - searchRange 
	USHORT endCount[segCountX2 / 2];	// End characterCode for each segment, last=0xFFFF. 
	USHORT reservedPad;	// Set to 0. 
	USHORT startCount[segCountX2 / 2];	// Start character code for each segment. 
	SHORT idDelta[segCountX2 / 2];	// Delta for all character codes in segment. 
	USHORT idRangeOffset[segCountX2 / 2];	// Offsets into glyphIdArray or 0 
	local quad glyphid_seek = FTell();
	FSeek(cmap_subtable + 2);
	local USHORT tmplength = 14 + segCountX2 + 2 + segCountX2 + segCountX2 + segCountX2 + randomlength;
	USHORT length = {tmplength};
	FSeek(glyphid_seek);
	USHORT glyphIdArray[(length-(FTell()-cmap_subtable))/2 ];	// Glyph index array (arbitrary length) 
};

typedef struct tcmap_format6 {
	cmap_subtable = FTell();
	USHORT format;	// Format number is set to 6. 
	USHORT length;	// This is the length in bytes of the subtable.  
	USHORT language;	// Please see "Note on the language field in 'cmap' subtables" in this document. 
	USHORT firstCode;	// First character code of subrange. 
	USHORT entryCount;	// Number of character codes in subrange. 
	USHORT glyphIdArray [entryCount];	// Array of glyph index values for character codes in the range. 
};

typedef struct tcmap_format8 {
	cmap_subtable = FTell();
	USHORT format;	// Subtable format; set to 8. 
	USHORT reserved;	// Reserved; set to 0 
	ULONG length;	// Byte length of this subtable (including the header) 
	ULONG language;	// Please see "Note on the language field in 'cmap' subtables" in this document. 
	BYTE is32[8192];	// Tightly packed array of bits (8K bytes total) indicating whether the particular 16-bit (index) value is the start of a 32-bit character code  
	ULONG nGroups;	//  Number of groupings which follow  
	//Printf("nGroups is %d\n", nGroups);
	struct {
		ULONG  startCharCode;	//  First character code in this group; note that if this group is for one or more 16-bit character codes (which is determined from the is32 array), this 32-bit value will have the high 16-bits set to zero  
		ULONG  endCharCode;	//  Last character code in this group; same condition as listed above for the startCharCode  
		ULONG  startGlyphID;	//  Glyph index corresponding to the starting character code  
	} groupings[nGroups];
};

typedef struct tcmap_format12 {
	USHORT format;	// Subtable format; set to 12. 
	USHORT reserved;	// Reserved; set to 0 
	ULONG  length;	//  Byte length of this subtable (including the header)  
	ULONG language;	// Please see "Note on the language field in 'cmap' subtables" in this document. 
	ULONG  nGroups;	//  Number of groupings which follow  
	struct {
		ULONG  startCharCode;	//  First character code in this group  
		ULONG  endCharCode;	//  Last character code in this group  
		ULONG  startGlyphID;	//  Glyph index corresponding to the starting character code  
	} groupings[nGroups];
};

typedef struct tcmap {
    local quad cmap_table;	
	local quad next_cmap_record;

	cmap_table = FTell();
	USHORT version_cmap;	// Table version number (0).  
	USHORT numTables = {4};	// Number of encoding tables that follow. 

};

typedef struct  {
   // ttfId++;

	//TT_Fixed version;	//Table version number 0x00010000 for version 1.0. 
	unsigned long version;
	//TT_Fixed fontRevision;	// Set by font manufacturer. 
	unsigned long fontRevision;
	ULONG checkSumAdjustment;	// To compute: set it to 0, sum the entire font as ULONG, then store 0xB1B0AFBA - sum. 
	ULONG magicNumber;	// Set to 0x5F0F3CF5. 
	USHORT flags;	// lots of flags...
	/*
	Bit 0: Baseline for font at y=0;
	Bit 1: Left sidebearing point at x=0;
	Bit 2: Instructions may depend on point size; 
	Bit 3: Force ppem to integer values for all internal scaler math; may use fractional ppem sizes if this bit is clear; 
	Bit 4: Instructions may alter advance width (the advance widths might not scale linearly); 
	Bits 5-10: These should be set according to Apple's specification . However, they are not implemented in OpenType. 
	Bit 11: Font data is 'lossless,' as a result of having been compressed and decompressed with the Agfa MicroType Express engine.
	Bit 12: Font converted (produce compatible metrics)
	Bit 13: Font optimised for ClearType
	Bit 14: Reserved, set to 0
	Bit 15: Reserved, set to 0 
	 */
	USHORT unitsPerEm;	// Valid range is from 16 to 16384. This value should be a power of 2 for fonts that have TrueType outlines. 
	LONGDATETIME created;	// Number of seconds since 12:00 midnight, January 1, 1904. 64-bit integer 
	LONGDATETIME modified;	// Number of seconds since 12:00 midnight, January 1, 1904. 64-bit integer 
	SHORT xMin;	// For all glyph bounding boxes. 
	SHORT yMin;	// For all glyph bounding boxes. 
	SHORT xMax;	// For all glyph bounding boxes. 
	SHORT yMax;	// For all glyph bounding boxes. 
	USHORT macStyle;	//
	/*
	Bit 0: Bold (if set to 1); 
	Bit 1: Italic (if set to 1) 
	Bit 2: Underline (if set to 1) 
	Bit 3: Outline (if set to 1) 
	Bit 4: Shadow (if set to 1) 
	Bit 5: Condensed (if set to 1) 
	Bit 6: Extended (if set to 1) 
	Bits 7-15: Reserved (set to 0).  
	*/
	USHORT lowestRecPPEM;	//Smallest readable size in pixels. 
	SHORT fontDirectionHint;	//
	/*
	0: Fully mixed directional glyphs; 
	1: Only strongly left to right; 
	2: Like 1 but also contains neutrals; 
	-1: Only strongly right to left; 
	-2: Like -1 but also contains neutrals. 1 
	*/
	SHORT indexToLocFormat = {0};	// 0 for short offsets, 1 for long. 暂时设置为short	
	SHORT glyphDataFormat;	// 0 for current format. 
}thead;
typedef struct  {
	//TT_Fixed version;	// Table version number 0x00010000 for version 1.0. 
	unsigned long version;
	TT_FWord Ascender;	// Typographic ascent. (Distance from baseline of highest ascender)  
	TT_FWord Descender;	// Typographic descent. (Distance from baseline of lowest descender)  
	TT_FWord LineGap;	// Typographic line gap. 
		//Negative LineGap values are treated as zero 
		//in Windows 3.1, System 6, and 
		//System 7. 
	TT_UFWord advanceWidthMax;	// Maximum advance width value in 'hmtx' table. 
	TT_FWord minLeftSideBearing;	// Minimum left sidebearing value in 'hmtx' table. 
	TT_FWord minRightSideBearing;	// Minimum right sidebearing value; calculated as Min(aw - lsb - (xMax - xMin)). 
	TT_FWord xMaxExtent;	// Max(lsb + (xMax - xMin)). 
	SHORT caretSlopeRise;	// Used to calculate the slope of the cursor (rise/run); 1 for vertical. 
	SHORT caretSlopeRun;	// 0 for vertical. 
	SHORT caretOffset;	// The amount by which a slanted highlight on a glyph needs to be shifted to produce the best appearance. Set to 0 for non-slanted fonts 
	SHORT reserved;	// set to 0 
	SHORT reserved;	// set to 0 
	SHORT reserved;	// set to 0 
	SHORT reserved;	// set to 0 
	SHORT metricDataFormat;	// 0 for current format. 
	USHORT numberOfHMetrics;	// Number of hMetric entries in 'hmtx' table 
}thhea <read=thheaRead>;

string thheaRead( thhea &d ) {
	string s;
	SPrintf(s, "v%.2f %u hmtx records", d.version/65535.0, d.numberOfHMetrics);
	return s;
}
typedef struct 	tlongHorMetric {
	USHORT	advanceWidth;
	SHORT	lsb;
};
typedef struct {
	local ulong numberOfHMetrics = attf_numberOfHMetrics;
	struct tlongHorMetric hMetrics[numberOfHMetrics];
	// Paired advance width and left side bearing values for each glyph. The value numOfHMetrics comes from the 'hhea' table. 
	// If the font is monospaced, only one entry need be in the array, but that entry is required. The last entry applies to all subsequent glyphs. 
	//local ulong numLeftSideBearing = ( curTblLength - (FTell()-curTblOffset) )/2;
	local ulong numLeftSideBearing = 0;
	if(numLeftSideBearing){
		SHORT leftSideBearing[ numLeftSideBearing ];
	}	
	// Here the advanceWidth is assumed to be the same as the advanceWidth for the last entry above. 
	// The number of entries in this array is derived from numGlyphs (from 'maxp' table) minus numberOfHMetrics. 
	// This generally is used with a run of monospaced glyphs (e.g., Kanji fonts or Courier fonts). 
	// Only one run is allowed and it must be at the end. This allows a monospaced font to vary the left side bearing values for each glyph. 
}thmtx <read=thmtxRead>;

string thmtxRead(thmtx &d) {
	string s;
	SPrintf(s, "%u HMetrics %u leftSideBearing", d.numberOfHMetrics, d.numLeftSideBearing);
	return s;
}

typedef struct  {
	//TT_Fixed version = {0x00010000};	//Table version number 0x00005000 for version 0.5 
	unsigned long version = {0x00010000};
	//(Note the difference in the representation of a non-zero fractional part, in Fixed numbers.)  
	if (version == 0x00005000) {
		USHORT numGlyphs;	// The number of glyphs in the font. 
	} else {
		USHORT numGlyphs;	// The number of glyphs in the font. 
		USHORT maxPoints;	// Maximum points in a non-composite glyph. 
		USHORT maxContours;	// Maximum contours in a non-composite glyph. 
		USHORT maxCompositePoints;	// Maximum points in a composite glyph. 
		USHORT maxCompositeContours;	// Maximum contours in a composite glyph. 
		USHORT maxZones;	// 1 if instructions do not use the twilight zone (Z0), or 2 if instructions do use Z0; should be set to 2 in most cases. 
		USHORT maxTwilightPoints;	// Maximum points used in Z0. 
		USHORT maxStorage;	// Number of Storage Area locations.  
		USHORT maxFunctionDefs;	// Number of FDEFs. 
		USHORT maxInstructionDefs;	// Number of IDEFs. 
		USHORT maxStackElements;	// Maximum stack depth2. 
		USHORT maxSizeOfInstructions;	// Maximum byte count for glyph instructions. 
		USHORT maxComponentElements;	// Maximum number of components referenced at "top level" for any composite glyph. 
		USHORT maxComponentDepth;	// Maximum levels of recursion; 1 for simple components. 
	}
}tmaxp <read=tmaxpRead>;

string tmaxpRead(tmaxp &d) {
	string s;
	if (d.version == 0x00005000) {
		SPrintf( s, "v%.2f %u glyphs", d.version/65535.0, d.numGlyphs);
		}
	else {
		SPrintf( s, "v%.2f %u glyphs %u points %u contours", d.version/65535.0, d.numGlyphs,d.maxPoints,d.maxContours);
		}
	return s;
}

typedef struct {
		USHORT platformID;	// Platform ID. 
		USHORT encodingID;	// Platform-specific encoding ID. 
		USHORT languageID;	// Language ID. 
		USHORT nameID;	// Name ID. 
		USHORT length;	// String length (in bytes). 
		USHORT offset;	// String offset from start of storage area (in bytes). 
	} NameRecord ;
	//<read=NameRecordRead, optimize = false>;

typedef struct  {
// http://www.microsoft.com/typography/OTSPEC/name.htm
	local quad name_table = FTell();
	USHORT format = {0};	// Format selector (=0). 
	USHORT count;	// Number of name records. 
	local USHORT name_soffset = count * 12 + 6;
	USHORT stringOffset = {name_soffset};	// Offset to start of string storage (from start of table). 
	local quad NextNameRecord;

	
}tname;

/*string NameRecordRead( tNameRecord &d ) {
	string s;
	SPrintf( s, "p%i E%i L%i %s", d.platformID, d.encodingID, d.languageID, d.name );
	return s;
}*/

string tnameRead(tname &name) {
	string s;
	SPrintf(s, "%li Names", name.count);
	return s;
}

typedef struct  {
	// http://www.microsoft.com/typography/OTSPEC/os2.htm
	USHORT version_tos;	// 0x0003 
	SHORT xAvgCharWidth;
	USHORT usWeightClass;
	USHORT usWidthClass;
	USHORT fsType;
	SHORT ySubscriptXSize;
	SHORT ySubscriptYSize;
	SHORT ySubscriptXOffset;
	SHORT ySubscriptYOffset;
	SHORT ySuperscriptXSize;
	SHORT ySuperscriptYSize;
	SHORT ySuperscriptXOffset;
	SHORT ySuperscriptYOffset;
	SHORT yStrikeoutSize;
	SHORT yStrikeoutPosition;
	SHORT sFamilyClass;
	struct tpanose {
		UBYTE bFamilyType;
		UBYTE bSerifStyle;
		UBYTE bWeight;
		UBYTE bProportion;
		UBYTE bContrast;
		UBYTE bStrokeVariation;
		UBYTE bArmStyle;
		UBYTE bLetterform;
		UBYTE bMidline;
		UBYTE bXHeight;
	} panose;
	ULONG ulUnicodeRange1;	// Bits 0-31 
	ULONG ulUnicodeRange2;	// Bits 32-63 
	ULONG ulUnicodeRange3;	// Bits 64-95 
	ULONG ulUnicodeRange4;	// Bits 96-127 
	CHAR achVendID[4];
	USHORT fsSelection;
	USHORT usFirstCharIndex;
	USHORT usLastCharIndex;
	SHORT sTypoAscender;
	SHORT sTypoDescender;
	SHORT sTypoLineGap;
	USHORT usWinAscent;
	USHORT usWinDescent;
	ULONG ulCodePageRange1;	// Bits 0-31 
	ULONG ulCodePageRange2;	// Bits 32-63 
	SHORT sxHeight;
	SHORT sCapHeight;
	USHORT usDefaultChar;
	USHORT usBreakChar;
	USHORT usMaxContext;
}tOS_2 <read=tOS_2Read>;

string tOS_2Read(tOS_2 &d) {
	string s;
	SPrintf(s, "v%i chars %i to %i from %4s", d.version_tos, d.usFirstCharIndex, d.usLastCharIndex, d.achVendID);
	return s;
}

typedef struct  {
	local quad post = FTell();
	//TT_Fixed version = {0x00020000, 0x00025000};
	unsigned long version = {0x00020000, 0x00025000};
	//TT_Fixed italicAngle;	// Italic angle in counter-clockwise degrees from the vertical. Zero for upright text, negative for text that leans to the right (forward). 
	unsigned long italicAngle;
	TT_FWord underlinePosition;	// This is the suggested distance of the top of the underline from the baseline (negative values indicate below baseline). 
	TT_FWord underlineThickness;	// Suggested values for the underline thickness. 
	ULONG isFixedPitch;	// Set to 0 if the font is proportionally spaced, non-zero if the font is not proportionally spaced (i.e. monospaced). 
	ULONG minMemType42;	// Minimum memory usage when an OpenType font is downloaded. 
	ULONG maxMemType42;	// Maximum memory usage when an OpenType font is downloaded. 
	ULONG minMemType1;	// Minimum memory usage when an OpenType font is downloaded as a Type 1 font. 
	ULONG maxMemType1;	// Maximum memory usage when an OpenType font is downloaded as a Type 1 font. 
	if (version == 0x00020000) {
		USHORT numberOfGlyphs;	// Number of glyphs (this should be the same as numGlyphs in 'maxp' table). 
		local ushort numGlyphs = numberOfGlyphs; //? Assumption TODO: Verify. Seems to work
		USHORT glyphNameIndex[numGlyphs];	//This is not an offset, but is the ordinal number of the glyph in 'post' string tables. 
		local ushort numberNewGlyphs = numberOfGlyphs; //? Assumption FALSE TODO: FIX
		//local quad end_name = post+curTblLength;
		//local quad next_name = FTell();
	//	while (next_name < end_name) {
			struct tpostName {
				UBYTE length;
				CHAR  text[length];
			} name[10] <read=tpostNameRead>;
			//next_name = FTell();
		//}	// Glyph names with length bytes [variable] (a Pascal string). 
	}
	if (version == 0x00025000) {
		USHORT numberOfGlyphs;	// Number of glyphs (this should be the same as numGlyphs in 'maxp' table). 
		local ushort numGlyphs = numberOfGlyphs; //? Assumption TODO: Verify. Seems to work
		USHORT tpostoffset[numGlyphs];	//This is not an offset, but is the ordinal number of the glyph in 'post' string tables. 
	}
}tpost;

string tpostNameRead( tpostName &d ) {
	return d.text;	//use this instead to get the Unicode, etc... characters.
}

string tpostRead( tpost &d ) {
	string s;
	if ((d.version == 0x00020000) || (d.version == 0x00025000)){
		SPrintf( s, "version %.2f %u glyphs", d.version/65535.0, d.numberOfGlyphs);
	} else {
		SPrintf(s, "version %.2f", d.version/65535.0);
	}
	
	if (d.isFixedPitch) {
		s += " fixed pitch"; 
	} else { 
		s += " proportional"; 
	}
	return s;
};

typedef struct tcvt {
	//local quad n = curTblLength / sizeof(TT_FWord);
	//local quad n = curTblLength / 2;
	//local int tcvtevil = SetEvilBit(false);
	//Printf("tcvtevil is %d\n", tcvtevil);
	TT_FWord value[5];	// List of n values referenceable by instructions. n is the number of FWORD items that fit in the size of the table. 
};

typedef struct tfpgm {
	//local quad n = curTblLength / sizeof(UBYTE);
	//local quad n = curTblLength / 1;
	//local int tfpgmevil = SetEvilBit(false);
	//Printf("tfpgmevil is %d\n", tfpgmevil);
	UBYTE bytecode[10];	// Instructions. n is the number of BYTE items that fit in the size of the table. 
};

typedef struct  {
	local ulong tloca_n = attf_numGlyphs + 1;
	local int t;
	local short format = attf_indexToLocFormat;
	//local USHORT localoffsets[tloca_n];
	if (format == 0) {
		//USHORT	offsets[tloca_n];
		
		for(t = 0; t < tloca_n; t ++)
		{
			uchar offsets_h = {0};
			uchar offsets_l;
			//localoffsets = offsets_l;
		}
	} else {
		//ULONG	offsets[tloca_n];
		for(t = 0; t < tloca_n; t ++)
		{
			uchar offsets_1h = {0};
			uchar offsets_1l = {0};
			uchar offsets_2h = {0};
			uchar offsets_2l;
		}
	}
}tloca <read=tlocaRead>;

string tlocaRead(tloca &d) {
	string s;
	if (d.format == 0) {
		SPrintf(s, "%u short offsets", d.n);
	} else {
		SPrintf(s, "%u long offsets", d.n);
	}
	return s;
}

typedef struct  {
	local ulong i_sgp;
	local quad yusn_start;
	local quad xStart, xLast; 
	yusn_start = xStart = xLast = FTell();
	local quad yStart, yLast; 
	yStart = FTell(); // 
	//Printf("xStart: %u\n",yStart);
	yLast = 0;
	local byte xLastByte = 0;
	local byte yLastByte = 0;
	//Printf("tSimpleGlyphPoints numPoints\n");
	//Printf("numPoints is %d\n", numPoints);
	for (i_sgp = 0; i_sgp < numPoints; i_sgp++) {
		if ((SimpleGlyph_flag[i_sgp] & X_BYTE) && !(SimpleGlyph_flag[i_sgp] & X_TYPE)) {
			yStart++; 
			if (!(SimpleGlyph_flag[i_sgp] & X_BYTE)) {
				yStart++;
			}
			// when flag bit 3 is not set, the x coordinate for that point is another byte long
		}
	}
	// Now we can decode points in pairs...
	local int g_lenngth = 0;
	for (i_sgp = 0; i_sgp < numPoints; i_sgp++) {

        if( !(SimpleGlyph_flag[i_sgp] & X_BYTE) && (SimpleGlyph_flag[i_sgp] & X_TYPE) )
            FSeek(xLast);
        else
            FSeek(xStart);

		struct tPoints{
			if (SimpleGlyph_flag[i_sgp] & X_BYTE) {
				xLast = FTell();
				xLastByte=1;
				UBYTE xDelta;
				//Printf("xDelta\n");
				g_lenngth ++;
				xStart = FTell();
			} else {
				if ((SimpleGlyph_flag[i_sgp] & X_TYPE)) {
					FSeek(xLast);
					if (xLast>0) {
						if (xLastByte) {
							UBYTE xDeltaRepeat; 
							g_lenngth ++;
							//Printf("xDeltaRepeat\n");
						} else { 
							SHORT xDeltaRepeat;
							g_lenngth += 2;
							//Printf("xDeltaRepeat\n");
						}
					}
				} else {
					xLast = FTell();
					xLastByte=0;
					SHORT xDelta;
					g_lenngth += 2;
					//Printf("xDelta\n");
					xStart = FTell();
				}
			}
			
			FSeek(yStart);
			if (SimpleGlyph_flag[i_sgp] & Y_BYTE) {
				yLast = FTell();
				yLastByte=1;
				UBYTE yDelta;
				g_lenngth ++;
				//Printf("yDelta\n");
				yStart = FTell();
			} else {
				if ((SimpleGlyph_flag[i_sgp] & Y_TYPE)) {
					FSeek(yLast);
					if (yLast>0) {
						if (yLastByte) {
							UBYTE yDeltaRepeat;
							g_lenngth ++;
							//Printf("yDeltaRepeat\n");
						} else {
							SHORT yDeltaRepeat;
							g_lenngth += 2;
							//Printf("yDeltaRepeat\n");
						}
					}
				} else {
					yLast = FTell();
					yLastByte=0;
					SHORT yDelta;
					g_lenngth += 2;
					//Printf("yDelta\n");
					yStart = FTell();
				}
			}
		FSeek(xStart);
		//First coordinates relative to (0,0); others are relative to previous point. 
		} points <optimize=true>;
	}
	//FSeek(yusn_start + g_lenngth);
}tSimpleGlyphPoints;

string tPointsRead ( tSimpleGlyphPoints &d ) {
	string s;
	s="hello";
	return s;
}

typedef struct  {
	//typedef UBYTE bitFlag;
	local UBYTE flag_repeat=0;
	
	if (flag_repeat) {
		UBYTE count;
		flag_repeat = 0;
	}
	else {
		//Printf("BitfieldRightToLeft\n");
		BitfieldRightToLeft();
		
		UBYTE	onCurve ;
		UBYTE	xByte ;
		UBYTE	yByte ;
		UBYTE	repeat;
		UBYTE	xType ;
		UBYTE	yType ;
		//Printf("BitfieldRightToLeft fuck\n");
		if (repeat) flag_repeat = 1;
	}
}tSimpleGlyphFlags;
 //<read=tSimpleGlyphFlagsRead>;

string tSimpleGlyphFlagsRead (tSimpleGlyphFlags &d) {
	string s;
	if (exists(d.count)) {
		SPrintf(s, " repeat %u times", d.count);
	}
	else {
		s="Point";
		if (d.onCurve) s += " OnCurve";
		if (!d.xByte) {s += " X"; if (d.xType) s += "R";}
		if (d.xByte) {s += " x"; if (d.xType) s += "+"; else s += "-";}
		if (!d.yByte) {s += " Y"; if (d.yType) s += "R";}
		if (d.yByte) {s += " y"; if (d.yType) s += "+"; else s += "-";}
		if (d.repeat) s += " REPEAT:";
	}
	return s;
}
local ubyte SimpleGlyph_flag[256];
typedef struct  {
	local int n;
	ubyte numberOfContoursh = {0};
	ubyte numberOfContoursl;
	SHORT xMin;	// Minimum x for coordinate data. 
	SHORT yMin;	// Minimum y for coordinate data. 
	SHORT xMax;	// Maximum x for coordinate data. 
	SHORT yMax;	// Maximum y for coordinate data. 
	//Printf("numberOfContoursl is %d\n", numberOfContoursl);
	local USHORT numPoints;
	for(n = 0; n < numberOfContoursl; n ++)
	{
		ubyte endPtsOfContoursh = {0};
		ubyte endPtsOfContoursl ;
		if(n == (numberOfContoursl - 1))
		{
			numPoints = endPtsOfContoursl;
		}
	}
	//USHORT endPtsOfContours[numberOfContoursl];	// Array of last points of each contour; n is the number of contours. 
	//USHORT instructionLength;	// Total number of bytes for instructions. 
	ubyte instructionLength_h = {0};
	ubyte instructionLength_l;
	if (instructionLength_l > 0) {
		//Printf("instructionLength_l is %d\n", instructionLength_l);
		UBYTE instructions[instructionLength_l];	// Array of instructions for each glyph
	}
	
	
	//Printf("numPoints is %d\n", numPoints);
	// Unpack the compressed flags table
	local quad glyf_flag_table = FTell();
	local quad glyf_flag_index = FTell();
	local ushort i;
	local ubyte repeat = 0;
	
	//flag[0] = 1;
	// we have to do this in a local, 'cause of the run length compression from the "repeat" flag
	local ubyte flag_value;
	for (i = 0; i < numPoints; i++) {
		if (repeat > 0) {
			repeat--;
		} else {
			flag_value = ReadUByte(glyf_flag_index++);
			//Printf("flag_value is %d\n", flag_value);
			SimpleGlyph_flag[i] = flag_value;
			//only increment the pointer to the number of flags if the count on a repeat is 0
			if (SimpleGlyph_flag[i] & 8) {
				repeat = ReadUByte(glyf_flag_index++);
			}
		}
		SimpleGlyph_flag[i] = flag_value;
	}
	
	local ushort numFlags = glyf_flag_index - glyf_flag_table;
	//Printf("numFlags is %d\n", numFlags);
	//struct tSimpleGlyphFlags flag;
	struct {
		tSimpleGlyphFlags flag[numFlags] <read=tSimpleGlyphFlagsRead>;
		//tSimpleGlyphFlags <optimize=false, tSimpleGlyphFlagsRead>;
	} compressedFlags;
	// Array of flags for each coordinate in outline; n is the number of flags. 
	//`-----------------------------------

	struct tSimpleGlyphPoints contours;
} tSimpleGlyph ;
//<read=tSimpleGlyphRead>;

typedef struct tglyf {
	local quad glyf_table = FTell(); //获取文本初始位置
	local quad glyf_offset; 
	//The indexToLoc table stores the offsets to the locations of the glyphs in the font,
	// relative to the beginning of the glyphData table. 
	//In order to compute the length of the last glyph element, there is an extra entry 
	// after the last valid index. 
	local ulong n;

	//The (maximum) value of n is numGlyphs + 1. The value for numGlyphs is found in the 'maxp' table.
	if (maxGlyfRead == 0)
		maxGlyfRead = attf_numGlyphs;
	
	
	//FSeek(glyf_table); //定位回到 tglyf结构体初始的位置
	local USHORT tSimpleGlyph_length = 0; //用来计算每个SimpleGlyph的大小
	//Printf("maxGlyfRead %d\n", maxGlyfRead);
	for (n = 0; n <= maxGlyfRead; n++) { 
		
		local int index_g = 0;
		//FSeek(attf_locatell); //定位到local表的位置
	
		if (attf_indexToLocFormat == 0) 
		{
			index_g = 2; //为 short的大小偏移
		} 
		else 
		{
			index_g = 4;
		}
		
		FSeek(attf_locatell + index_g * n);  //seek定位 local表加 n* index_g
		if(attf_indexToLocFormat == 0)
		{
		//	local USHORT locaoffsets = ReadUShort(FTell());
			local USHORT locaoffsets = 0;
			//Printf("locaoffsets %d\n", locaoffsets);
			local USHORT l_offset = locaoffsets + tSimpleGlyph_length; //重新计算偏移
			//Printf("l_offset %d\n", l_offset);
			USHORT local_offset = {l_offset}; //重新赋值给 local表

			glyf_offset = l_offset;
		}
		else
		{
			local ULONG locaoffsets = ReadUInt(FTell());
			//Printf("locaoffsets %d\n", locaoffsets);
			local ULONG l_offset = locaoffsets + tSimpleGlyph_length;
			//ULONG local_offset = {l_offset};
			ULONG local_offset = {100};
			glyf_offset = l_offset;

		}
		//FSeek(start_gly); //定位到gly初始的位置
		
		//The actual local offset is stored, assuming the long version 
		//The version is specified by 'indexToLocFormat' in the head table. 0 for Short, 1 for Long.
		if (attf_indexToLocFormat == 0) {
			glyf_offset *= 2;
		}
		//In the short version, the actual local offset divided by 2 is stored.
		//Printf("glyf_offset %d\n", glyf_offset);
		FSeek(glyf_table + glyf_offset);
		local quad start_gly = FTell(); //记录gly初始的位置
		
		//if (ReadUByte(FTell()) > 0) {
			//Printf("tSimpleGlyph \n");
			// If the number of contours is greater than or equal to zero, this is a single glyph;
			struct tSimpleGlyph SimpleGlyph <read = tSimpleGlyphRead>;
		//}

		/*else if (ReadUByte(FTell()) < 0 & 0==1) { // UNTESTED CODE. TODO: test
			// If the number of contours is negative, this is a composite glyph. 
			//-------------------------------
			Printf("else tSimpleGlyph \n");
			SHORT numberOfContours;	
			SHORT xMin;	// Minimum x for coordinate data. 
			SHORT yMin;	// Minimum y for coordinate data. 
			SHORT xMax;	// Maximum x for coordinate data. 
			SHORT yMax;	// Maximum y for coordinate data. 
			do {
				USHORT flags;
				struct tGlyph {
					USHORT glyphIndex;
					if ( flags & ARG_1_AND_2_ARE_WORDS) {
						SHORT argument1;
						SHORT argument2;
					}
					else {
						USHORT arg1and2; 
					}
					if (flags & WE_HAVE_A_SCALE) {
						F2Dot14  scale;    
					}
					else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
						F2Dot14  xscale;    
						F2Dot14  yscale;    
					}
					else if (flags & WE_HAVE_A_TWO_BY_TWO) {
						F2Dot14  xscale;    
						F2Dot14  scale01;   
						F2Dot14  scale10;   
						F2Dot14  yscale;    
					}
					if (flags & WE_HAVE_INSTRUCTIONS) {
						USHORT numInstr;
						BYTE instr[numInstr];
					}
				} Glyph;
			} while (flags & MORE_COMPONENTS);
			//-------------------------------
		}*/
		tSimpleGlyph_length += FTell() - start_gly;
		//Printf("tSimpleGlyph_length %d\n", tSimpleGlyph_length);

	}
};

string tSimpleGlyphRead( tSimpleGlyph &d ) {
	string s;
	SPrintf( s, "%u contours %u insts %u flags %u points", d.numberOfContours, d.instructionLength, d.numFlags, d.numPoints);
	return s;
}

typedef struct tprep {
	//local quad n = curTblLength / sizeof(UBYTE);
	//local quad n = curTblLength / 1;
	//local int tprepevil = SetEvilBit(false);
	//Printf("tprepevil is %d\n", tprepevil);
	UBYTE bytecode[10];	// Instructions. n is the number of BYTE items that fit in the size of the table. 
};

typedef struct tGDEF {
	//TT_Fixed Version;	// Version of the GDEF table-initially 0x00010000 
	unsigned long Version = {0x00010000};
	TT_Offset GlyphClassDef;	// Offset to class definition table for glyph type-from beginning of GDEF header (may be NULL) 
	TT_Offset AttachList;	// Offset to list of glyphs with attachment points-from beginning of GDEF header (may be NULL) 
	TT_Offset LigCaretList;	// Offset to list of positioning points for ligature carets-from beginning of GDEF header (may be NULL) 
	TT_Offset MarkAttachClassDef;	// Offset to class definition table for mark attachment type-from beginning of GDEF header (may be NULL) 
};
local quad tLangSysTable_ftell;
typedef struct tLangSysTable{
	USHORT LookupOrder = {0}; // = NULL (reserved for an offset to a reordering table) 
	uint16 ReqFeatureIndex = {0xFFFF}; 
	//uint16 FeatureCount; 
	ubyte FeatureCounth = {0};
	ubyte FeatureCountl = {5};
	uint16 FeatureIndex[FeatureCountl]; // Array of indices into the FeatureList-in arbitrary order 
	//Printf("FeatureCounth  is %d\n", FeatureCounth);
	//Printf("FeatureCountl  is %d\n", FeatureCountl);
	tLangSysTablelength = 6 + 2 * FeatureCountl;

};
local USHORT tLangSysTablelength = 0;
struct tLangSysRecord(ubyte LangSysCount) {
	char LangSysTag[4];	// 4-byte LangSysTag identifier 
	local USHORT tLanglength = 4 + LangSysCount * 6 + LangSysRecordlength;
	USHORT Offset = {tLanglength}; // LangSys Offset to LangSys table-from beginning of Script table 
	local quad next = FTell();
	//Printf("LangSysCount  is %d\n", LangSysCount);
	//Printf("tLanglength  is %d\n", tLanglength);
	FSeek(ScriptTable_table + Offset);
	local quad LangSys=FTell();
	
 	tLangSysTable LangSysTable;
 	//Printf("tLangSysTablelength  is %d\n", tLangSysTablelength);
 	//Printf("LangSysRecordlength  is %d\n", LangSysRecordlength);
 	//LangSysRecordlength += tLangSysTablelength;
 	LangSysRecordlength += (FTell() - LangSys);
 	//Printf("LangSysRecordlength  is %d\n", LangSysRecordlength);

 	tLangSysTable_ftell = FTell();
	FSeek(next);
};
//<read=tLangSysRecordRead>;

/*string tLangSysRecordRead (tLangSysRecord &d ) {
	return d.LangSysTag;
}*/
local quad ScriptTable_table;
local USHORT LangSysRecordlength;
struct  tScriptRecord(ubyte ScriptCount){
	char ScriptTag[4];	//4-byte ScriptTag identifier 
	local USHORT soffset_l = 2 + ScriptCount * 6 + ScriptRecordlength;
	USHORT Offset = {soffset_l}; // to Script table-from beginning of ScriptList 
	//Printf("tScriptRecord soffset_l is %d\n", soffset_l);
	local quad next = FTell();
	FSeek(ScriptList_seek + Offset);
	ScriptTable_table=FTell();
	local int l_cont; 
	struct {
		USHORT DefaultLangSys;	// Offset to DefaultLangSys table-from beginning of Script table-may be NULL 
		//uint16 LangSysCount;	// Number of LangSysRecords for this script-excluding the DefaultLangSys 
		ubyte LangSysCounth = {0};
		ubyte LangSysCountl = {3};
		//if (LangSysCount){
		LangSysRecordlength = 0;
		//Printf("tScriptRecord LangSysCountl is %d\n", LangSysCountl);
		for(l_cont = 0; l_cont < LangSysCountl; l_cont ++)
		{

			tLangSysRecord LangSysRecord(LangSysCountl);
			// <optimize=false, read=tLangSysRecordRead>; 
		}
		//}
			//Array of LangSysRecords-listed alphabetically by LangSysTag 
	} ScriptTable;
	local USHORT DefaultLangSyslength = 4 + LangSysCountl * 6;
	FSeek(ScriptTable_table);
	USHORT DefaultLangSys = {DefaultLangSyslength};
	//Printf("DefaultLangSyslength  is %d\n", DefaultLangSyslength);
	FSeek(ScriptList_seek + Offset + DefaultLangSyslength);
	tLangSysTable DefaultLangSysTable;
	//ScriptRecordlength += (FTell() - ScriptTable_table);
	ScriptRecordlength += LangSysRecordlength;
	ScriptRecordlength += tLangSysTablelength;
	ScriptRecordlength += DefaultLangSyslength;
	ScriptRecordlength += 6;
	FSeek(next);
};
// <read=tScriptRecordRead>;

/*string tScriptRecordRead (tScriptRecord &d) {
	return d.ScriptTag;
}*/
local quad ScriptList_seek;
typedef struct  {
	//local int count;
	USHORT Offset = {10}; //Offset to ScriptList table-from beginning of GSUB table 
	local quad next = FTell();
	FSeek(GSUBorGPOS_table + Offset);
	ScriptList_seek=FTell();
	uint16 ScriptCountl = {3}; //Number of ScriptRecords 
	//ubyte ScriptCounth = {0};
	//ubyte ScriptCountl = {2};
	//Printf("ScriptCountl  is %d\n", ScriptCountl);
	local USHORT ScriptRecordlength = 0;
	for(i = 0; i < ScriptCountl; i ++)
	{
		//Printf("ScriptCountl!!!!!\n");
		tScriptRecord ScriptRecord(ScriptCountl);
	}
	
	//<read=tScriptRecordRead, optimize = false>; 
	//Array of ScriptRecords -listed alphabetically by ScriptTag 
	FSeek(next);
}tScriptList;
/* <read=tScriptListRead>;

string tScriptListRead (tScriptList &d) {
	string s;
	SPrintf( s, "%u scripts", d.ScriptCount);
	return s;
}*/

typedef struct  tFeatureRecord(ubyte FeatureCount){
	char FeatureTag[4];	//4-byte FeatureTag identifier 
	local USHORT tmptFeatureRecord = 2 + 6 * FeatureCount + tFeatureRecordlength;
	USHORT Offset = {tmptFeatureRecord}; // to Feature table-from beginning of FeatureList 
	local quad next = FTell();
	FSeek(FeatureList_seek + Offset);
	local quad FeatureTable_table=FTell();
	struct {
		uint16 FeatureParams;	//reserved null
		//uint16 LookupListCount;	// Number of LangSysRecords for this script-excluding the DefaultLangSys
		ubyte  LookupListCounth = {0};
		ubyte  LookupListCountl = {10};
		uint16 LookupListIndex[LookupListCountl] <optimize = false>; 

	} FeatureTable <optimize = false>;
	tFeatureRecordlength += (FTell() - FeatureTable_table);
	tFeatureListlengthseek = FTell();//获取最后的定位
	FSeek(next);
};
// <read=tFeatureRecordRead>;


local quad FeatureList_seek;
local quad tFeatureListlengthseek;
typedef struct tFeatureList(USHORT tFeaturelength) {
	//local int f;
	USHORT Offset = {tFeaturelength}; //Offset to FeatureList table-from beginning of GSUB table 
	//Printf("tFeaturelength  is %d\n", tFeaturelength);
	local quad next = FTell();
	FSeek(GSUBorGPOS_table + Offset);
	FeatureList_seek=FTell();
	//uint16 FeatureCount; //Number of FeatureRecords 
	ubyte FeatureCounth = {0};
	ubyte FeatureCountl = {5};
	//Printf("FeatureCountl  is %d\n", FeatureCountl);
	local USHORT tFeatureRecordlength = 0;
	for( i = 0; i < FeatureCountl; i ++)
	{
		tFeatureRecord FeatureRecord(FeatureCountl);
	}
	//FeatureList_seek = FTell();//获取最后的定位
	// <read= tFeatureRecordRead, optimize = false>; 
	//Array of FeatureRecords -listed alphabetically by FeatureTag 
	FSeek(next);
};
// <read=tFeatureListRead>;

/*string tFeatureListRead (tFeatureList &d) {
	string s;
	SPrintf( s, "%u Features", d.FeatureCount);
	return s;
}
*/

typedef struct tLookupRecord(ubyte LookupCount) {
	local USHORT tmptLookupRecord = LookupCount * 2 + 2 + tLookupRecordlength;
	USHORT Offset = {tmptLookupRecord}; //Offset to LookupList table-from beginning of GSUB table 
	local quad next = FTell();
	FSeek(LookupList_table + Offset);
	local quad tLookupRecord_table = FTell();
	uint16 LookupType; //Different enumerations for GSUB and GPOS 
	uint16 LookupFlag; //Lookup qualifiers 
	//uint16 SubTableCount; //Number of SubTables for this lookup 
	ubyte SubTableCounth = {0};
	ubyte SubTableCountl = {10};
	USHORT SubTable[SubTableCountl]; //Array of offsets to SubTables-from beginning of Lookup table  
	tLookupRecordlength += (FTell() - tLookupRecord_table);
	FSeek(next);
};
local quad LookupList_table;
typedef struct tLookupList (USHORT tLookupListlength){
	//local int l;
	USHORT Offset = {tLookupListlength}; //Offset to LookupList table-from beginning of GSUB table 
	local quad next = FTell();
	FSeek(GSUBorGPOS_table + Offset);
	LookupList_table=FTell();
	//uint16 LookupCount; //Number of FeatureRecords 
	ubyte LookupCounth = {0};
	ubyte LookupCountl = {5};
	local USHORT tLookupRecordlength = 0;
	for(i = 0; i < LookupCountl; i ++)
	{
		tLookupRecord LookupRecord(LookupCountl) <optimize = false>; 
	}
	//Array of LookupRecords -listed alphabetically by LookupTag 
	//FSeek(next);
};

typedef struct  tGSUBorGPOS{
	local quad GSUBorGPOS_table = FTell();
	//TT_Fixed Version; //Version of the GSUB table-initially set to 0x00010000 
	unsigned long Version = {0x00010000};

	tScriptList ScriptList <read=tScriptListRead>; //Offset to ScriptList table-from beginning of GSUB table 
	local USHORT Fllength = tLangSysTable_ftell - GSUBorGPOS_table;
	tFeatureList FeatureList(Fllength);
	// <read=tFeatureListRead>; //Offset to FeatureList table-from beginning of GSUB table 
	local USHORT Lllength = tFeatureListlengthseek - GSUBorGPOS_table;
	tLookupList LookupList(Lllength); //Offset to LookupList table-from beginning of GSUB table 

	//LookupType Enumeration table for glyph substitution 

	//Value Type Description 
	//1 LookupType_Single Replace one glyph with one glyph 
	//2 LookupType_Multiple Replace one glyph with more than one glyph 
	//3 LookupType_Alternate Replace one glyph with one of many glyphs 
	//4 LookupType_Ligature Replace multiple glyphs with one glyph 
	//5 LookupType_Context Replace one or more glyphs in context 
	//6 LookupType_Chaining Context Replace one or more glyphs in chained context 
	//7 LookupType_Extension Substitution Extension mechanism for other substitutions (i.e. this excludes the Extension type substitution itself) 
	//8 LookupType_Reverse chaining context single  Applied in reverse order, replace single glyph in chaining context 
	//9+ Reserved For future use 
};/* <read=tGSUBorGPOSRead>;

string tGSUBorGPOSRead( tGSUBorGPOS &d ) {
	string s;
	SPrintf( s, "v%.2f", d.Version/65535.0);
	return s;
}*/
local quad nextSig;
local quad DSIG_table;
typedef struct  {
	DSIG_table = FTell();
	
    ULONG ulVersion = {0x00000001};	// Version number of the DSIG table (0x00000001) 
   // USHORT usNumSigs;	// Number of signatures in the table 
    UBYTE usNumSigsh = {0};
    UBYTE usNumSigsl  ;
    USHORT usFlag = {1};	// permission flags
	//Bit 0: cannot be resigned
	//Bits 1-7: Reserved (Set to 0) 
  //  struct {
  local USHORT SigsulLength = 0;
    for(i = 0; i < usNumSigsl; i ++)
    {
    	nextSig = FTell(); 
		FSeek(nextSig);
		ULONG ulFormat; //format of the signature 
		ULONG ulLength; //Length of signature in bytes 
		//local ULONG tmpSigul = 8  + 12 + 12 * i + SigsulLength;
		local ULONG tmpSigul = FTell() - DSIG_table + 4;
		ULONG ulOffset ={tmpSigul}; //Offset to the signature block from the beginning of the table 
		nextSig = FTell(); 
		FSeek(DSIG_table + ulOffset);
		USHORT usReserved1 = {0}; // Reserved for later use; 0 for now 
		USHORT usReserved2 = {0}; // Reserved for later use; 0 for now 
		USHORT cbSignatureh = {0};
		USHORT cbSignaturel ;

		//ULONG cbSignature; // Length (in bytes) of the PKCS#7 packet in pbSignature 
		UBYTE bSignature[cbSignaturel];	// PKCS#7 packet

		SigsulLength =  cbSignaturel;
		FSeek(nextSig - 8);
		tmpSigul = SigsulLength  + 8;
		ULONG ulLength = {tmpSigul};
		FSeek(nextSig + 8 + cbSignaturel);

    }
		
	//} Sigs[usNumSigs] <optimize = false>;
}tDSIG <read=tDSIGRead>;

string tDSIGRead( tDSIG &d ) {
	string s;
	SPrintf( s, "v%u %u signature(s)", d.ulVersion, d.usNumSigs);
	return s;
}

typedef struct  {
	USHORT version = {0};	// Table version number (0) 
	char numRecordsh = {0};
	char numRecordsl;
	//SHORT numRecords;	// Number of device records. 
	SHORT sizeDeviceRecordh ={0};
	SHORT sizeDeviceRecordl;
	//LONG sizeDeviceRecord;	// Size of a device record, long aligned. 
	struct {
		local quad hdmx_DeviceRecord = FTell();
		UBYTE pixelSize;	// Pixel size for following widths (as ppem). 
		UBYTE maxWidth;	// Maximum width. 
		local quad numGlyphs = (sizeDeviceRecordl - (FTell() - hdmx_DeviceRecord)) / 1;
		UBYTE widths[numGlyphs];	// Array of widths (numGlyphs is from the 'maxp' table). 
	} DeviceRecord[numRecordsl] <optimize=false>;
}thdmx <read=thdmxRead>;

string thdmxRead(thdmx &d) {
	string s;
	SPrintf(s, "Version %i %u records %u bytes", d.version, d.numRecords, d.sizeDeviceRecord);
	return s;
}

typedef struct tLTSH {
    USHORT ver;
    USHORT numGlyphs;
    UBYTE yPels[numGlyphs];
};

typedef struct tRatioRange {
	UBYTE bCharSet;
	UBYTE xRatio;
	UBYTE yStartRatio;
	UBYTE yEndRatio;
} RatioRange;
typedef struct tVDMXRecord {
	USHORT yPelHeight;
	SHORT yMax;
	SHORT yMin;
} VDMXRecord;
typedef struct tVDMXGroup {
	//USHORT recs;
	UBYTE recsh = {0};
	UBYTE recsl ;
	BYTE startsz;
	BYTE endsz;
	VDMXRecord entry[recsl];
} VDMXGroup;
typedef struct tVDMX {
	// header
	USHORT version;
	USHORT numRecs;
	//USHORT numRatios;
	UBYTE numRatiosh = {0};
	UBYTE numRatiosl ;
	RatioRange ratRange[numRatiosl];
	
	local USHORT  tmpVDMXGrouplength = numRatiosl * 2 + 6 +  numRatiosl * 4;
	//USHORT offset = {tmpVDMXGrouplength};
	local int64 tVDMXoffset = FTell();
	USHORT offsetl[numRatiosl];
	
	for(i = 0; i <numRatiosl; i ++)
	{
		local int64 VDMXGroupstar = FTell();
		FSeek(tVDMXoffset + i * 2);
		USHORT offset = {tmpVDMXGrouplength};
		FSeek(VDMXGroupstar);
		VDMXGroup groups <optimize=false>;
		local int64 VDMXGroupseek = FTell();
		tmpVDMXGrouplength = VDMXGroupseek - tVDMXoffset;
		// + 6 +  numRatiosl * 4;
		Printf("tmpVDMXGrouplength is %d\n", tmpVDMXGrouplength);
		FSeek(VDMXGroupseek);

	}
	//VDMXGroup groups[numRatiosl]<optimize=false>;
};

struct GaspBehavior
{
    uint16 gridfit : 1;
    uint16 doGray : 1;
    uint16 symMetricGridfit : 1;
    uint16 symMetricSmoothing : 1;
    uint16 Reserved : 12;
};

struct tgaspRange
{
    uint16 rangeMaxPPEM;
    GaspBehavior rangeGaspBehavior;
};

struct tgasp
{
    uint16 version = {0};
    uint16 numRanges;
    tgaspRange gaspRanges[numRanges];
};

// Tag Type
typedef union {
    char    asName[4];           
    ULONG asLong <format=hex>; 
} CTag <read=readCTag>;

string readCTag(local CTag &t) {
    return t.asName;
}
local int i = 0;
local ULONG offset_tag = 0;

typedef struct  {
	
   // CTag Tag ;
   local char asName[4];
    ReadBytes(asName, FTell(), 4);
    FSeek(FTell() + 4);
	ULONG checkSum;	// CheckSum for this table. 
	ULONG offset = {12 + numTables_n * 16 + offset_tag};
	ULONG length;	// Length of this table. 
	local int64 pos_start = FTell();
	FSeek(offset);
	if(asName == "head")
	{
		Printf("head table\n");
		thead head;
		
    	attf_indexToLocFormat = head.indexToLocFormat;
    	
	}
	 else if(asName == "cmap")
	{
		Printf("cmap table\n");
        struct tcmap cmap;
        local int c ;
        local ULONG cmap_length = 4;
        //local string preferred_cmap[] = { "0" };
		//local USHORT possible_cmap[] = { 0, 2, 4, 6, 8, 12 };
		local USHORT possible_cmap[] = { 0, 2, 4, 6 , 8, 12};
		//Printf("cmap numTablesis %d\n", cmap.numTables);
        for(c = 0 ; c < cmap.numTables; c ++)
        {
        	local quad cmap_subtable;
			local quad cmap_record;
			//local USHORT format_num;
			cmap_record = FTell();
			USHORT platformID;	// Platform ID. 
			USHORT encodingID;	// Platform-specific encoding ID. 
			//ULONG offset;	// Byte offset from beginning of table to the subtable for this encoding. 
			cmap.next_cmap_record = FTell();
			ULONG offset = {cmap_length + 8 * cmap.numTables};
			//Printf("cmap offset %d\n", offset);
			local quad format_seek = cmap.cmap_table + cmap_length + 8 * cmap.numTables;

			FSeek(format_seek);
			
			//FSeek(format_seek);
			//format_num[0] = "0";
			switch (ReadUShort(FTell(), possible_cmap)) {
				case 0: 
					//Printf("cmap format0\n");
					struct tcmap_format0 format0; 
					//Printf("format0 format %d\n", format0.format);
					//Printf("format0 length %d\n", format0.length);
					break;
				case 2:
					//Printf("cmap format2\n");
				 	struct tcmap_format2 format2;
				 	//Printf("format0 format %d\n", format2.format);
					//Printf("format0 length %d\n", format2.length);
				 	 break;
				case 4: 
					//Printf("cmap format4\n");
					struct tcmap_format4 format4; 
					//Printf("format4 format %d\n", format4.format);
					//Printf("format4 length %d\n", format4.length);
					break;
				case 6: 
					//Printf("cmap format6\n");
					struct tcmap_format6 format6; 
					//Printf("format0 format %d\n", format6.format);
					//Printf("format0 length %d\n", format6.length);
					break;
				case 8: 
					//Printf("cmap format8\n");
					struct tcmap_format8 format8; 
					break;
				//case 10: struct tcmap_format10 format10; break; //TODO
				case 12: 
					//Printf("cmap format12\n");
					struct tcmap_format12 format12; 
					break;
				}
			cmap_length += (FTell() - format_seek);
			FSeek(cmap.next_cmap_record + 4);
			

        }
        
	}
	else if(asName == "hhea")
	{
		Printf("hhea table\n");
        thhea hhea;
        attf_numberOfHMetrics = hhea.numberOfHMetrics;
        
	}
	else if(asName == "OS/2")
	{
		Printf("OS/2 table\n");
		struct tOS_2 OS_2 <read=tOS_2Read>;	
	}
	else if(asName == "maxp")
	{
		Printf("maxp table\n");
		struct tmaxp maxp <read=tmaxpRead>;
        attf_numGlyphs = maxp.numGlyphs;
        	
	}
	else if(asName == "hmtx")
	{
		Printf("hmtx table\n");
		struct thmtx hmtx<read=thmtxRead>;
		
	}
	else if(asName == "name")
	{
		Printf("name table\n");
		struct tname name <read=tnameRead>;
		local USHORT tmp_name_length = 0;
		local USHORT a = 0;
		//local int d = 0;
        for(a = 0 ; a < name.count; a ++)
        {
        	//struct NameRecord namerecord;	
        	USHORT name_platformID = {0};	// Platform ID. 
			USHORT name_encodingID = {0};	// Platform-specific encoding ID. 
			USHORT name_languageID = {0};	// Language ID. 
			USHORT name_nameID = {a};	// Name ID. 
			USHORT name_length;	// String length (in bytes). 
			USHORT name_offset = {tmp_name_length};	// String offset from start of storage area (in bytes). 
			tmp_name_length += 	name_length;
			name.NextNameRecord = FTell();
			FSeek(name.name_table + name.stringOffset + name_offset);
			/*for(d = 0; d < name_length; d ++)
			{
				ReadByte(FTell());
			}*/
						
			char namestrings[name_length];
			FSeek(name.NextNameRecord);
        }
	}
	else if(asName == "post")
	{
		Printf("post table\n");
		struct tpost post <read=tpostRead>;
	}
	else if(asName == "cvt ")
	{
		Printf("cvt table\n");
		struct tcvt  cvt ;
		
	}
	else if(asName == "fpgm")
	{
		Printf("fpgm table\n");
		struct tfpgm fpgm;
	}
	else if(asName == "loca")
	{
		Printf("loca table\n");
		attf_locatell = FTell();
        struct tloca loca <read=tlocaRead>;
	}
	else if(asName == "glyf")
	{
		Printf("glyf table\n");
		struct tglyf glyf;

	}
	else if(asName == "prep")
	{
		Printf("prep table\n");
		struct tprep prep;
	}
	else if(asName == "GDEF")
	{
		Printf("GDEF table\n");
		struct tGDEF GDEF;
	}
	else if(asName == "GSUB")
	{
		Printf("GSUB table\n");
		struct tGSUBorGPOS GSUB;// <read=tGSUBorGPOSRead>;
	}
	/*else if(asName == "GPOS")
	{
		struct tGSUBorGPOS GPOS;// <read=tGSUBorGPOSRead>;
	}*/
	else if(asName == "DSIG")
	{
		Printf("DSIG table\n");
		struct tDSIG DSIG <read=tDSIGRead>;
	}
	else if(asName == "hdmx")
	{
		Printf("hdmx table\n");
		struct thdmx hdmx <read=thdmxRead>;
	}
	else if(asName == "LTSH")
	{
		Printf("LTSH table\n");
		struct tLTSH LTSH;
	}
	else if(asName == "VDMX")
	{
		Printf("VDMX table\n");
		struct tVDMX VDMX;
	}
	else if(asName == "gasp")
	{
		Printf("gasp table\n");
		struct tgasp gasp;
	}
	local int64 pos_end = FTell();
	local uint32 correct_length = pos_end - pos_start;
	
	
	offset_tag += correct_length;
	FSeek(pos_start - 4);
	ULONG length = {correct_length};
	Printf("correct_length is %d\n", correct_length);

}tTable <read=tTableRead>;

string tTableRead( tTable &d ) {
	char s[50];
	SPrintf(s, "Table %s at offset: %u with size: %u", d.Tag.asName, d.offset, d.length);
	return s;
}

//struct over

struct TTCHeader
{
    char tag[4];
    uint16 majorVersion;
    uint16 minorVersion;
    uint32 numFonts;
    uint32 offsetTable[numFonts];
    if (majorVersion == 2)
    {
        char dsigTag[4];
        uint32 dsigLength<format=hex>;
        uint32 dsigOffset<format=hex>;
    }
};

local uint32 ttfId = 0;
local uint32 t_numFonts = 1;
/*if (ReadInt() == 0x74746366) // big-endian "ttcf"
{
    struct TTCHeader ttc;
    t_numFonts = ttc.numFonts;
}*/
//struct ttfFile ttf[numFonts]<optimize=false>;

//ChangeArrayLength();

local ULONG curTblOffset;
local ULONG curTblLength;

local USHORT attf_numberOfHMetrics;
local USHORT attf_numGlyphs;
local SHORT attf_indexToLocFormat;
local quad attf_glyf_offset;

local int64 attf_locatell;

//local int evil = SetEvilBit(false);
struct tOffsetTable OffsetTable;


local char tag_type[4];
local USHORT tablecount = 0;


typedef struct  {
	
    CTag Tag ;
	ULONG checkSum;	// CheckSum for this table. 
	ULONG offset ;
	ULONG length;	// Length of this table. 

}sTable;
local quad table_start_pos = FTell();
local string preferred_chunks[] = {"head"};
local string possible_chunks[] = { "head"};
while(ReadBytes(tag_type, FTell(), 4, preferred_chunks, possible_chunks)) 
{
	sTable stable;
	tablecount ++;
	switch (tag_type) {
    	case "head":
    		//local string preferred_chunks[] = { "hhea" };
    		local string preferred_chunks[0];
            local string possible_chunks[] = { "hhea", "prep","OS/2", "maxp" ,"name", "post", "cvt ",
             "fpgm", "cmap", "GDEF", "GSUB", "DSIG", "hdmx", "LTSH","VDMX", "gasp"};
           // local string possible_chunks[] = {"maxp"};
        break;
        case "hhea":
        	
        	possible_chunks -= "hhea";
        	possible_chunks += "hmtx";
        break;
        case "OS/2":
        	
        	possible_chunks -= "OS/2";
        break;

        case "maxp":
        	
        	possible_chunks -= "maxp";
        	possible_chunks += "loca";
        break;
        case "name":
        	
        	possible_chunks -= "name";
        case "hmtx":
        	
        	possible_chunks -= "hmtx";
        break;
        case "post":   
        				
        	possible_chunks -= "post";
        break;
        case "cvt ":  
        				
        	possible_chunks -= "cvt ";
        break;
        case "fpgm":
        	
        	possible_chunks -= "fpgm";
        break;
        case "loca":
        	
        	possible_chunks -= "loca";
        	possible_chunks += "glyf";
        break;
        case "glyf":
        	
        	//possible_chunks -= "glyf";
        	local string preferred_chunks[0];
        	local string possible_chunks[0];
        break;
        case "prep":
        	
        	possible_chunks -= "prep";       			
        break;
        case "GDEF":
        	
        	possible_chunks -= "GDEF";  
        break; 	
        case "GSUB":
        	
        	possible_chunks -= "GSUB";     			
        break;		
        case "GPOS":
        	
        	possible_chunks -= "GPOS";
        			
        break;
        case "DSIG":
        	
        	possible_chunks -= "DSIG";
        			
        break;
        case "hdmx":
        	
        	possible_chunks -= "hdmx";
        			
        break;
        case "LTSH":
        	
        	possible_chunks -= "LTSH";
        			
        break;
        case "VDMX":
        	
        	possible_chunks -= "VDMX";
        			
        break;
        case "gasp":
        	
        	possible_chunks -= "gasp";
        			
        break;
        case "cmap":
        	
        	possible_chunks -= "cmap";
        	
        break;

        
    }
}

FSeek(numTables_offset);
USHORT  numTables = {tablecount};
numTables_n = tablecount;

FSeek(table_start_pos);
local int t;
for(t = 0; t < tablecount; t ++)
{

	tTable Table;
}

Printf("OffsetTable.numTables is %d\n", numTables_n);
//Printf("OffsetTable.searchRange is %d\n", OffsetTable.searchRange);
//Printf("OffsetTable.entrySelector is %d\n", OffsetTable.entrySelector);
//Printf("OffsetTable.rangeShift is %d\n", OffsetTable.rangeShift);


